import { Observable } from 'rxjs';
import { CacheStorageService, StorageCacheItem } from './cache-storage';
import * as ɵngcc0 from '@angular/core';
export interface CacheConfig {
    keyPrefix?: string;
}
export declare const MESSAGES: {
    0: string;
    1: string;
    2: string;
    3: string;
    4: string;
};
export declare type CacheValueFactory<T> = () => Promise<T>;
export declare class CacheService {
    private _storage;
    private ttl;
    private cacheEnabled;
    private invalidateOffline;
    private networkStatusChanges;
    private networkStatus;
    static request: any;
    static response: any;
    static responseOptions: any;
    static httpDeprecated: boolean;
    constructor(_storage: CacheStorageService);
    private loadCache();
    private loadHttp();
    ready(): Promise<any>;
    /**
     * @description Disable or enable cache
     */
    enableCache(enable?: boolean): void;
    /**
     * @description Delete DB table and create new one
     * @return {Promise<any>}
     */
    private resetDatabase();
    /**
     * @description Set default TTL
     * @param {number} ttl - TTL in seconds
     */
    setDefaultTTL(ttl: number): number;
    /**
     * @description Set if expired cache should be invalidated if device is offline
     * @param {boolean} offlineInvalidate
     */
    setOfflineInvalidate(offlineInvalidate: boolean): void;
    /**
     * @description Start watching if devices is online or offline
     */
    private watchNetworkInit();
    /**
     * @description Stream of network status changes
     * * @return {Observable<boolean>} network status stream
     */
    getNetworkStatusChanges(): Observable<boolean>;
    /**
     * @description Check if devices is online
     * @return {boolean} network status
     */
    isOnline(): boolean;
    /**
     * @description Save item to cache
     * @param {string} key - Unique key
     * @param {any} data - Data to store
     * @param {string} [groupKey] - group key
     * @param {number} [ttl] - TTL in seconds
     * @return {Promise<any>} - saved data
     */
    saveItem(key: string, data: any, groupKey?: string, ttl?: number): Promise<any>;
    /**
     * @description Delete item from cache
     * @param {string} key - Unique key
     * @return {Promise<any>} - query execution promise
     */
    removeItem(key: string): Promise<any>;
    /**
     * @description Removes all items with a key that matches pattern
     * @return {Promise<any>}
     */
    removeItems(pattern: string): Promise<any>;
    /**
     * @description Get item from cache without expire check etc.
     * @param {string} key - Unique key
     * @return {Promise<any>} - data from cache
     */
    getRawItem<T = any>(key: string): Promise<StorageCacheItem>;
    getRawItems(): Promise<StorageCacheItem[]>;
    /**
     * @description Check if item exists in cache regardless if expired or not
     * @param {string} key - Unique key
     * @return {Promise<boolean | string>} - boolean - true if exists
     */
    itemExists(key: string): Promise<boolean | string>;
    /**
     * @description Get item from cache with expire check and correct type assign
     * @param {string} key - Unique key
     * @return {Promise<any>} - data from cache
     */
    getItem<T = any>(key: string): Promise<T>;
    getOrSetItem<T>(key: string, factory: CacheValueFactory<T>, groupKey?: string, ttl?: number): Promise<T>;
    /**
     * @description Decode raw data from DB
     * @param {any} data - Data
     * @return {any} - decoded data
     */
    static decodeRawData(data: StorageCacheItem): any;
    /**
     * @description Load item from cache if it's in cache or load from origin observable
     * @param {string} key - Unique key
     * @param {any} observable - Observable with data
     * @param {string} [groupKey] - group key
     * @param {number} [ttl] - TTL in seconds
     * @return {Observable<any>} - data from cache or origin observable
     */
    loadFromObservable<T = any>(key: string, observable: any, groupKey?: string, ttl?: number): Observable<T>;
    /**
     * @description Load item from cache if it's in cache or load from origin observable
     * @param {string} key - Unique key
     * @param {any} observable - Observable with data
     * @param {string} [groupKey] - group key
     * @param {number} [ttl] - TTL in seconds
     * @param {string} [delayType='expired']
     * @param {string} [metaKey] - property on T to which to assign meta data
     * @return {Observable<any>} - data from cache or origin observable
     */
    loadFromDelayedObservable<T = any>(key: string, observable: Observable<T>, groupKey?: string, ttl?: number, delayType?: string, metaKey?: string): Observable<T>;
    /**
     * Perform complete cache clear
     * @return {Promise<any>}
     */
    clearAll(): Promise<any>;
    /**
     * @description Remove all expired items from cache
     * @param {boolean} ignoreOnlineStatus -
     * @return {Promise<any>} - query promise
     */
    clearExpired(ignoreOnlineStatus?: boolean): Promise<any>;
    /**
     * @description Remove all item with specified group
     * @param {string} groupKey - group key
     * @return {Promise<any>} - query promise
     */
    clearGroup(groupKey: string): Promise<any>;
    /**
     * @description Check if it's an request
     * @param {any} data - Variable to test
     * @return {boolean} - data from cache
     */
    static isRequest(data: any): boolean;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<CacheService, never>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<CacheService>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FjaGUuc2VydmljZS5kLnRzIiwic291cmNlcyI6WyJjYWNoZS5zZXJ2aWNlLmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvSkEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBDYWNoZVN0b3JhZ2VTZXJ2aWNlLCBTdG9yYWdlQ2FjaGVJdGVtIH0gZnJvbSAnLi9jYWNoZS1zdG9yYWdlJztcbmV4cG9ydCBpbnRlcmZhY2UgQ2FjaGVDb25maWcge1xuICAgIGtleVByZWZpeD86IHN0cmluZztcbn1cbmV4cG9ydCBkZWNsYXJlIGNvbnN0IE1FU1NBR0VTOiB7XG4gICAgMDogc3RyaW5nO1xuICAgIDE6IHN0cmluZztcbiAgICAyOiBzdHJpbmc7XG4gICAgMzogc3RyaW5nO1xuICAgIDQ6IHN0cmluZztcbn07XG5leHBvcnQgZGVjbGFyZSB0eXBlIENhY2hlVmFsdWVGYWN0b3J5PFQ+ID0gKCkgPT4gUHJvbWlzZTxUPjtcbmV4cG9ydCBkZWNsYXJlIGNsYXNzIENhY2hlU2VydmljZSB7XG4gICAgcHJpdmF0ZSBfc3RvcmFnZTtcbiAgICBwcml2YXRlIHR0bDtcbiAgICBwcml2YXRlIGNhY2hlRW5hYmxlZDtcbiAgICBwcml2YXRlIGludmFsaWRhdGVPZmZsaW5lO1xuICAgIHByaXZhdGUgbmV0d29ya1N0YXR1c0NoYW5nZXM7XG4gICAgcHJpdmF0ZSBuZXR3b3JrU3RhdHVzO1xuICAgIHN0YXRpYyByZXF1ZXN0OiBhbnk7XG4gICAgc3RhdGljIHJlc3BvbnNlOiBhbnk7XG4gICAgc3RhdGljIHJlc3BvbnNlT3B0aW9uczogYW55O1xuICAgIHN0YXRpYyBodHRwRGVwcmVjYXRlZDogYm9vbGVhbjtcbiAgICBjb25zdHJ1Y3Rvcihfc3RvcmFnZTogQ2FjaGVTdG9yYWdlU2VydmljZSk7XG4gICAgcHJpdmF0ZSBsb2FkQ2FjaGUoKTtcbiAgICBwcml2YXRlIGxvYWRIdHRwKCk7XG4gICAgcmVhZHkoKTogUHJvbWlzZTxhbnk+O1xuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBEaXNhYmxlIG9yIGVuYWJsZSBjYWNoZVxuICAgICAqL1xuICAgIGVuYWJsZUNhY2hlKGVuYWJsZT86IGJvb2xlYW4pOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBEZWxldGUgREIgdGFibGUgYW5kIGNyZWF0ZSBuZXcgb25lXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIHByaXZhdGUgcmVzZXREYXRhYmFzZSgpO1xuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBTZXQgZGVmYXVsdCBUVExcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdHRsIC0gVFRMIGluIHNlY29uZHNcbiAgICAgKi9cbiAgICBzZXREZWZhdWx0VFRMKHR0bDogbnVtYmVyKTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBTZXQgaWYgZXhwaXJlZCBjYWNoZSBzaG91bGQgYmUgaW52YWxpZGF0ZWQgaWYgZGV2aWNlIGlzIG9mZmxpbmVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9mZmxpbmVJbnZhbGlkYXRlXG4gICAgICovXG4gICAgc2V0T2ZmbGluZUludmFsaWRhdGUob2ZmbGluZUludmFsaWRhdGU6IGJvb2xlYW4pOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBTdGFydCB3YXRjaGluZyBpZiBkZXZpY2VzIGlzIG9ubGluZSBvciBvZmZsaW5lXG4gICAgICovXG4gICAgcHJpdmF0ZSB3YXRjaE5ldHdvcmtJbml0KCk7XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uIFN0cmVhbSBvZiBuZXR3b3JrIHN0YXR1cyBjaGFuZ2VzXG4gICAgICogKiBAcmV0dXJuIHtPYnNlcnZhYmxlPGJvb2xlYW4+fSBuZXR3b3JrIHN0YXR1cyBzdHJlYW1cbiAgICAgKi9cbiAgICBnZXROZXR3b3JrU3RhdHVzQ2hhbmdlcygpOiBPYnNlcnZhYmxlPGJvb2xlYW4+O1xuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBDaGVjayBpZiBkZXZpY2VzIGlzIG9ubGluZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IG5ldHdvcmsgc3RhdHVzXG4gICAgICovXG4gICAgaXNPbmxpbmUoKTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb24gU2F2ZSBpdGVtIHRvIGNhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFVuaXF1ZSBrZXlcbiAgICAgKiBAcGFyYW0ge2FueX0gZGF0YSAtIERhdGEgdG8gc3RvcmVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2dyb3VwS2V5XSAtIGdyb3VwIGtleVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdHRsXSAtIFRUTCBpbiBzZWNvbmRzXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxhbnk+fSAtIHNhdmVkIGRhdGFcbiAgICAgKi9cbiAgICBzYXZlSXRlbShrZXk6IHN0cmluZywgZGF0YTogYW55LCBncm91cEtleT86IHN0cmluZywgdHRsPzogbnVtYmVyKTogUHJvbWlzZTxhbnk+O1xuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBEZWxldGUgaXRlbSBmcm9tIGNhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFVuaXF1ZSBrZXlcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPGFueT59IC0gcXVlcnkgZXhlY3V0aW9uIHByb21pc2VcbiAgICAgKi9cbiAgICByZW1vdmVJdGVtKGtleTogc3RyaW5nKTogUHJvbWlzZTxhbnk+O1xuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBSZW1vdmVzIGFsbCBpdGVtcyB3aXRoIGEga2V5IHRoYXQgbWF0Y2hlcyBwYXR0ZXJuXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIHJlbW92ZUl0ZW1zKHBhdHRlcm46IHN0cmluZyk6IFByb21pc2U8YW55PjtcbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb24gR2V0IGl0ZW0gZnJvbSBjYWNoZSB3aXRob3V0IGV4cGlyZSBjaGVjayBldGMuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFVuaXF1ZSBrZXlcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPGFueT59IC0gZGF0YSBmcm9tIGNhY2hlXG4gICAgICovXG4gICAgZ2V0UmF3SXRlbTxUID0gYW55PihrZXk6IHN0cmluZyk6IFByb21pc2U8U3RvcmFnZUNhY2hlSXRlbT47XG4gICAgZ2V0UmF3SXRlbXMoKTogUHJvbWlzZTxTdG9yYWdlQ2FjaGVJdGVtW10+O1xuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBDaGVjayBpZiBpdGVtIGV4aXN0cyBpbiBjYWNoZSByZWdhcmRsZXNzIGlmIGV4cGlyZWQgb3Igbm90XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFVuaXF1ZSBrZXlcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPGJvb2xlYW4gfCBzdHJpbmc+fSAtIGJvb2xlYW4gLSB0cnVlIGlmIGV4aXN0c1xuICAgICAqL1xuICAgIGl0ZW1FeGlzdHMoa2V5OiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4gfCBzdHJpbmc+O1xuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBHZXQgaXRlbSBmcm9tIGNhY2hlIHdpdGggZXhwaXJlIGNoZWNrIGFuZCBjb3JyZWN0IHR5cGUgYXNzaWduXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFVuaXF1ZSBrZXlcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPGFueT59IC0gZGF0YSBmcm9tIGNhY2hlXG4gICAgICovXG4gICAgZ2V0SXRlbTxUID0gYW55PihrZXk6IHN0cmluZyk6IFByb21pc2U8VD47XG4gICAgZ2V0T3JTZXRJdGVtPFQ+KGtleTogc3RyaW5nLCBmYWN0b3J5OiBDYWNoZVZhbHVlRmFjdG9yeTxUPiwgZ3JvdXBLZXk/OiBzdHJpbmcsIHR0bD86IG51bWJlcik6IFByb21pc2U8VD47XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uIERlY29kZSByYXcgZGF0YSBmcm9tIERCXG4gICAgICogQHBhcmFtIHthbnl9IGRhdGEgLSBEYXRhXG4gICAgICogQHJldHVybiB7YW55fSAtIGRlY29kZWQgZGF0YVxuICAgICAqL1xuICAgIHN0YXRpYyBkZWNvZGVSYXdEYXRhKGRhdGE6IFN0b3JhZ2VDYWNoZUl0ZW0pOiBhbnk7XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uIExvYWQgaXRlbSBmcm9tIGNhY2hlIGlmIGl0J3MgaW4gY2FjaGUgb3IgbG9hZCBmcm9tIG9yaWdpbiBvYnNlcnZhYmxlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFVuaXF1ZSBrZXlcbiAgICAgKiBAcGFyYW0ge2FueX0gb2JzZXJ2YWJsZSAtIE9ic2VydmFibGUgd2l0aCBkYXRhXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtncm91cEtleV0gLSBncm91cCBrZXlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3R0bF0gLSBUVEwgaW4gc2Vjb25kc1xuICAgICAqIEByZXR1cm4ge09ic2VydmFibGU8YW55Pn0gLSBkYXRhIGZyb20gY2FjaGUgb3Igb3JpZ2luIG9ic2VydmFibGVcbiAgICAgKi9cbiAgICBsb2FkRnJvbU9ic2VydmFibGU8VCA9IGFueT4oa2V5OiBzdHJpbmcsIG9ic2VydmFibGU6IGFueSwgZ3JvdXBLZXk/OiBzdHJpbmcsIHR0bD86IG51bWJlcik6IE9ic2VydmFibGU8VD47XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uIExvYWQgaXRlbSBmcm9tIGNhY2hlIGlmIGl0J3MgaW4gY2FjaGUgb3IgbG9hZCBmcm9tIG9yaWdpbiBvYnNlcnZhYmxlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFVuaXF1ZSBrZXlcbiAgICAgKiBAcGFyYW0ge2FueX0gb2JzZXJ2YWJsZSAtIE9ic2VydmFibGUgd2l0aCBkYXRhXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtncm91cEtleV0gLSBncm91cCBrZXlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3R0bF0gLSBUVEwgaW4gc2Vjb25kc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbZGVsYXlUeXBlPSdleHBpcmVkJ11cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW21ldGFLZXldIC0gcHJvcGVydHkgb24gVCB0byB3aGljaCB0byBhc3NpZ24gbWV0YSBkYXRhXG4gICAgICogQHJldHVybiB7T2JzZXJ2YWJsZTxhbnk+fSAtIGRhdGEgZnJvbSBjYWNoZSBvciBvcmlnaW4gb2JzZXJ2YWJsZVxuICAgICAqL1xuICAgIGxvYWRGcm9tRGVsYXllZE9ic2VydmFibGU8VCA9IGFueT4oa2V5OiBzdHJpbmcsIG9ic2VydmFibGU6IE9ic2VydmFibGU8VD4sIGdyb3VwS2V5Pzogc3RyaW5nLCB0dGw/OiBudW1iZXIsIGRlbGF5VHlwZT86IHN0cmluZywgbWV0YUtleT86IHN0cmluZyk6IE9ic2VydmFibGU8VD47XG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBjb21wbGV0ZSBjYWNoZSBjbGVhclxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBjbGVhckFsbCgpOiBQcm9taXNlPGFueT47XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uIFJlbW92ZSBhbGwgZXhwaXJlZCBpdGVtcyBmcm9tIGNhY2hlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpZ25vcmVPbmxpbmVTdGF0dXMgLVxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8YW55Pn0gLSBxdWVyeSBwcm9taXNlXG4gICAgICovXG4gICAgY2xlYXJFeHBpcmVkKGlnbm9yZU9ubGluZVN0YXR1cz86IGJvb2xlYW4pOiBQcm9taXNlPGFueT47XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uIFJlbW92ZSBhbGwgaXRlbSB3aXRoIHNwZWNpZmllZCBncm91cFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBncm91cEtleSAtIGdyb3VwIGtleVxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8YW55Pn0gLSBxdWVyeSBwcm9taXNlXG4gICAgICovXG4gICAgY2xlYXJHcm91cChncm91cEtleTogc3RyaW5nKTogUHJvbWlzZTxhbnk+O1xuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBDaGVjayBpZiBpdCdzIGFuIHJlcXVlc3RcbiAgICAgKiBAcGFyYW0ge2FueX0gZGF0YSAtIFZhcmlhYmxlIHRvIHRlc3RcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSAtIGRhdGEgZnJvbSBjYWNoZVxuICAgICAqL1xuICAgIHN0YXRpYyBpc1JlcXVlc3QoZGF0YTogYW55KTogYm9vbGVhbjtcbn1cbiJdfQ==