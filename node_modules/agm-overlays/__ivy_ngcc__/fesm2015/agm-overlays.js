import { __decorate } from 'tslib';
import { EventEmitter, QueryList, Input, Output, ContentChildren, ViewChild, ElementRef, Component, NgModule } from '@angular/core';
import { GoogleMapsAPIWrapper, MarkerManager, AgmInfoWindow } from '@agm/core';
import { CommonModule } from '@angular/common';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@agm/core';

const _c0 = ["content"];
const _c1 = ["*"];
let AgmOverlay = class AgmOverlay {
    constructor(_mapsWrapper, _markerManager //rename to fight the private declaration of parent
    ) {
        this._mapsWrapper = _mapsWrapper;
        this._markerManager = _markerManager;
        this.visible = true; //possibly doesn't work and just left over from agm-core marker replication
        this.zIndex = 1;
        //TIP: Do NOT use this... Just put (click) on your html overlay element
        this.markerClick = new EventEmitter();
        this.openInfoWindow = true;
        this.infoWindow = new QueryList();
        //TODO, implement this
        this.draggable = false;
        //elmGuts:any
        this._observableSubscriptions = [];
    }
    ngAfterViewInit() {
        //remove reference of info windows
        const iWins = this.template.nativeElement.getElementsByTagName('agm-info-window');
        for (let x = iWins.length - 1; x >= 0; --x) {
            iWins[x].parentNode.removeChild(iWins[x]);
        }
        this.load().then(() => {
            this.onChanges = this.onChangesOverride;
        });
    }
    ngAfterContentInit() {
        this.infoWindow.changes.subscribe(() => this.handleInfoWindowUpdate());
    }
    ngOnChanges(changes) {
        this.onChanges(changes);
    }
    onChanges(changes) { }
    onChangesOverride(changes) {
        if (changes.latitude || changes.longitude || changes.zIndex) {
            this.overlayView.latitude = this.latitude;
            this.overlayView.longitude = this.longitude;
            this.overlayView.zIndex = this.zIndex;
            this.destroy().then(() => this.load());
        }
    }
    ngOnDestroy() {
        this.destroy();
    }
    destroy() {
        this.destroyed = true;
        const promise = this._markerManager.deleteMarker(this.overlayView);
        if (this.overlayView) {
            if (this.overlayView.div) {
                this.overlayView.remove();
            }
            this.overlayView.setMap(null);
        }
        this._observableSubscriptions.forEach((s) => s.unsubscribe());
        delete this.overlayView;
        //delete this.elmGuts
        return promise;
    }
    handleInfoWindowUpdate() {
        if (this.infoWindow.length > 1) {
            throw new Error('Expected no more than one info window.');
        }
        this.infoWindow.forEach(iWin => {
            iWin.hostMarker = this.overlayView;
        });
    }
    load() {
        return this._mapsWrapper.getNativeMap()
            .then(map => {
            const overlay = this.getOverlay(map);
            this._markerManager.addMarker(overlay);
            this._addEventListeners();
            return this._markerManager.getNativeMarker(overlay);
        })
            .then(nativeMarker => {
            const setMap = nativeMarker.setMap;
            if (nativeMarker['map']) {
                this.overlayView.setMap(nativeMarker['map']);
            }
            nativeMarker.setMap = (map) => {
                setMap.call(nativeMarker, map);
                if (this.overlayView) {
                    this.overlayView.setMap(map);
                }
            };
        });
    }
    getOverlay(map) {
        this.overlayView = this.overlayView || new google.maps.OverlayView();
        /* make into foo marker that AGM likes */
        this.overlayView.iconUrl = " ";
        this.overlayView.latitude = this.latitude;
        this.overlayView.longitude = this.longitude;
        this.overlayView.visible = false; //hide 40x40 transparent placeholder that prevents hover events
        /* end */
        if (this.bounds) {
            this.overlayView.bounds_ = new google.maps.LatLngBounds(new google.maps.LatLng(this.latitude + this.bounds.x.latitude, this.longitude + this.bounds.x.longitude), new google.maps.LatLng(this.latitude + this.bounds.y.latitude, this.longitude + this.bounds.y.longitude));
        }
        // js-marker-clusterer does not support updating positions. We are forced to delete/add and compensate for .removeChild calls
        const elm = this.template.nativeElement.children[0];
        //const elm =  this.elmGuts || this.template.nativeElement.children[0]
        //we must always be sure to steal our stolen element back incase we are just in middle of changes and will redraw
        const restore = (div) => {
            this.template.nativeElement.appendChild(div);
        };
        this.overlayView.remove = function () {
            if (!this.div)
                return;
            this.div.parentNode.removeChild(this.div);
            restore(this.div);
            delete this.div;
        };
        this.overlayView.getDiv = function () {
            return this.div;
        };
        this.overlayView.draw = function () {
            if (!this.div) {
                this.div = elm;
                const panes = this.getPanes();
                // if no panes then assumed not on map
                if (!panes || !panes.overlayImage)
                    return;
                panes.overlayImage.appendChild(elm);
            }
            const latlng = new google.maps.LatLng(this.latitude, this.longitude);
            const proj = this.getProjection();
            if (!proj)
                return;
            const point = proj.fromLatLngToDivPixel(latlng);
            if (point) {
                elm.style.left = (point.x - 10) + 'px';
                elm.style.top = (point.y - 20) + 'px';
            }
            if (this.bounds_) {
                // stretch content between two points leftbottom and righttop and resize
                const proj = this.getProjection();
                const sw = proj.fromLatLngToDivPixel(this.bounds_.getSouthWest());
                const ne = proj.fromLatLngToDivPixel(this.bounds_.getNorthEast());
                this.div.style.left = sw.x + 'px';
                this.div.style.top = ne.y + 'px';
                this.div.children[0].style.width = ne.x - sw.x + 'px';
                this.div.children[0].style.height = sw.y - ne.y + 'px';
            }
        };
        elm.addEventListener("click", event => {
            this.handleTap();
            event.stopPropagation();
        });
        this.handleInfoWindowUpdate();
        return this.overlayView;
    }
    handleTap() {
        if (this.openInfoWindow) {
            this.infoWindow.forEach(infoWindow => {
                infoWindow.open();
            });
        }
        this.markerClick.emit(null);
    }
    _addEventListeners() {
        const eo = this._markerManager.createEventObservable('click', this.overlayView);
        const cs = eo.subscribe(() => this.handleTap());
        this._observableSubscriptions.push(cs);
    }
};
AgmOverlay.ɵfac = function AgmOverlay_Factory(t) { return new (t || AgmOverlay)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.GoogleMapsAPIWrapper), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.MarkerManager)); };
AgmOverlay.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: AgmOverlay, selectors: [["agm-overlay"]], contentQueries: function AgmOverlay_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, AgmInfoWindow, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.infoWindow = _t);
    } }, viewQuery: function AgmOverlay_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, true, ElementRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.template = _t.first);
    } }, inputs: { visible: "visible", zIndex: "zIndex", openInfoWindow: "openInfoWindow", draggable: ["markerDraggable", "draggable"], latitude: "latitude", longitude: "longitude", bounds: "bounds" }, outputs: { markerClick: "markerClick" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c1, decls: 4, vars: 0, consts: [["content", ""], [2, "position", "absolute"]], template: function AgmOverlay_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", null, 0);
        ɵngcc0.ɵɵelementStart(2, "div", 1);
        ɵngcc0.ɵɵprojection(3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } }, encapsulation: 2 });
AgmOverlay.ctorParameters = () => [
    { type: GoogleMapsAPIWrapper },
    { type: MarkerManager //rename to fight the private declaration of parent
     }
];
__decorate([
    Input()
], AgmOverlay.prototype, "latitude", void 0);
__decorate([
    Input()
], AgmOverlay.prototype, "longitude", void 0);
__decorate([
    Input()
], AgmOverlay.prototype, "visible", void 0);
__decorate([
    Input()
], AgmOverlay.prototype, "zIndex", void 0);
__decorate([
    Input()
], AgmOverlay.prototype, "bounds", void 0);
__decorate([
    Output()
], AgmOverlay.prototype, "markerClick", void 0);
__decorate([
    Input()
], AgmOverlay.prototype, "openInfoWindow", void 0);
__decorate([
    ContentChildren(AgmInfoWindow)
], AgmOverlay.prototype, "infoWindow", void 0);
__decorate([
    Input('markerDraggable')
], AgmOverlay.prototype, "draggable", void 0);
__decorate([
    ViewChild('content', { read: ElementRef })
], AgmOverlay.prototype, "template", void 0);

let AgmOverlays = class AgmOverlays {
};
AgmOverlays.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: AgmOverlays });
AgmOverlays.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function AgmOverlays_Factory(t) { return new (t || AgmOverlays)(); }, imports: [[
            CommonModule
        ]] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AgmOverlay, [{
        type: Component,
        args: [{
                selector: "agm-overlay",
                template: '<div #content><div style="position:absolute"><ng-content></ng-content></div></div>'
            }]
    }], function () { return [{ type: ɵngcc1.GoogleMapsAPIWrapper }, { type: ɵngcc1.MarkerManager }]; }, { visible: [{
            type: Input
        }], zIndex: [{
            type: Input
        }], markerClick: [{
            type: Output
        }], openInfoWindow: [{
            type: Input
        }], infoWindow: [{
            type: ContentChildren,
            args: [AgmInfoWindow]
        }], draggable: [{
            type: Input,
            args: ['markerDraggable']
        }], latitude: [{
            type: Input
        }], longitude: [{
            type: Input
        }], bounds: [{
            type: Input
        }], template: [{
            type: ViewChild,
            args: ['content', { read: ElementRef }]
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(AgmOverlays, { declarations: function () { return [AgmOverlay]; }, imports: function () { return [CommonModule]; }, exports: function () { return [AgmOverlay]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AgmOverlays, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule
                ],
                declarations: [AgmOverlay],
                exports: [AgmOverlay]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { AgmOverlay, AgmOverlays };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWdtLW92ZXJsYXlzLmpzIiwic291cmNlcyI6WyJhZ20tb3ZlcmxheXMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7QUFLQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzZCQW9LRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7NkNBbUMyQyxBQU05Qjs7Ozs7OztFQUdiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswQkFTYyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9fZGVjb3JhdGUgfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIsIFF1ZXJ5TGlzdCwgSW5wdXQsIE91dHB1dCwgQ29udGVudENoaWxkcmVuLCBWaWV3Q2hpbGQsIEVsZW1lbnRSZWYsIENvbXBvbmVudCwgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEdvb2dsZU1hcHNBUElXcmFwcGVyLCBNYXJrZXJNYW5hZ2VyLCBBZ21JbmZvV2luZG93IH0gZnJvbSAnQGFnbS9jb3JlJztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5cbmxldCBBZ21PdmVybGF5ID0gY2xhc3MgQWdtT3ZlcmxheSB7XG4gICAgY29uc3RydWN0b3IoX21hcHNXcmFwcGVyLCBfbWFya2VyTWFuYWdlciAvL3JlbmFtZSB0byBmaWdodCB0aGUgcHJpdmF0ZSBkZWNsYXJhdGlvbiBvZiBwYXJlbnRcbiAgICApIHtcbiAgICAgICAgdGhpcy5fbWFwc1dyYXBwZXIgPSBfbWFwc1dyYXBwZXI7XG4gICAgICAgIHRoaXMuX21hcmtlck1hbmFnZXIgPSBfbWFya2VyTWFuYWdlcjtcbiAgICAgICAgdGhpcy52aXNpYmxlID0gdHJ1ZTsgLy9wb3NzaWJseSBkb2Vzbid0IHdvcmsgYW5kIGp1c3QgbGVmdCBvdmVyIGZyb20gYWdtLWNvcmUgbWFya2VyIHJlcGxpY2F0aW9uXG4gICAgICAgIHRoaXMuekluZGV4ID0gMTtcbiAgICAgICAgLy9USVA6IERvIE5PVCB1c2UgdGhpcy4uLiBKdXN0IHB1dCAoY2xpY2spIG9uIHlvdXIgaHRtbCBvdmVybGF5IGVsZW1lbnRcbiAgICAgICAgdGhpcy5tYXJrZXJDbGljayA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5vcGVuSW5mb1dpbmRvdyA9IHRydWU7XG4gICAgICAgIHRoaXMuaW5mb1dpbmRvdyA9IG5ldyBRdWVyeUxpc3QoKTtcbiAgICAgICAgLy9UT0RPLCBpbXBsZW1lbnQgdGhpc1xuICAgICAgICB0aGlzLmRyYWdnYWJsZSA9IGZhbHNlO1xuICAgICAgICAvL2VsbUd1dHM6YW55XG4gICAgICAgIHRoaXMuX29ic2VydmFibGVTdWJzY3JpcHRpb25zID0gW107XG4gICAgfVxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgLy9yZW1vdmUgcmVmZXJlbmNlIG9mIGluZm8gd2luZG93c1xuICAgICAgICBjb25zdCBpV2lucyA9IHRoaXMudGVtcGxhdGUubmF0aXZlRWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYWdtLWluZm8td2luZG93Jyk7XG4gICAgICAgIGZvciAobGV0IHggPSBpV2lucy5sZW5ndGggLSAxOyB4ID49IDA7IC0teCkge1xuICAgICAgICAgICAgaVdpbnNbeF0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpV2luc1t4XSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2FkKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlcyA9IHRoaXMub25DaGFuZ2VzT3ZlcnJpZGU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgICAgIHRoaXMuaW5mb1dpbmRvdy5jaGFuZ2VzLnN1YnNjcmliZSgoKSA9PiB0aGlzLmhhbmRsZUluZm9XaW5kb3dVcGRhdGUoKSk7XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgdGhpcy5vbkNoYW5nZXMoY2hhbmdlcyk7XG4gICAgfVxuICAgIG9uQ2hhbmdlcyhjaGFuZ2VzKSB7IH1cbiAgICBvbkNoYW5nZXNPdmVycmlkZShjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChjaGFuZ2VzLmxhdGl0dWRlIHx8IGNoYW5nZXMubG9uZ2l0dWRlIHx8IGNoYW5nZXMuekluZGV4KSB7XG4gICAgICAgICAgICB0aGlzLm92ZXJsYXlWaWV3LmxhdGl0dWRlID0gdGhpcy5sYXRpdHVkZTtcbiAgICAgICAgICAgIHRoaXMub3ZlcmxheVZpZXcubG9uZ2l0dWRlID0gdGhpcy5sb25naXR1ZGU7XG4gICAgICAgICAgICB0aGlzLm92ZXJsYXlWaWV3LnpJbmRleCA9IHRoaXMuekluZGV4O1xuICAgICAgICAgICAgdGhpcy5kZXN0cm95KCkudGhlbigoKSA9PiB0aGlzLmxvYWQoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLl9tYXJrZXJNYW5hZ2VyLmRlbGV0ZU1hcmtlcih0aGlzLm92ZXJsYXlWaWV3KTtcbiAgICAgICAgaWYgKHRoaXMub3ZlcmxheVZpZXcpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm92ZXJsYXlWaWV3LmRpdikge1xuICAgICAgICAgICAgICAgIHRoaXMub3ZlcmxheVZpZXcucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm92ZXJsYXlWaWV3LnNldE1hcChudWxsKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9vYnNlcnZhYmxlU3Vic2NyaXB0aW9ucy5mb3JFYWNoKChzKSA9PiBzLnVuc3Vic2NyaWJlKCkpO1xuICAgICAgICBkZWxldGUgdGhpcy5vdmVybGF5VmlldztcbiAgICAgICAgLy9kZWxldGUgdGhpcy5lbG1HdXRzXG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICBoYW5kbGVJbmZvV2luZG93VXBkYXRlKCkge1xuICAgICAgICBpZiAodGhpcy5pbmZvV2luZG93Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgbm8gbW9yZSB0aGFuIG9uZSBpbmZvIHdpbmRvdy4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluZm9XaW5kb3cuZm9yRWFjaChpV2luID0+IHtcbiAgICAgICAgICAgIGlXaW4uaG9zdE1hcmtlciA9IHRoaXMub3ZlcmxheVZpZXc7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsb2FkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwc1dyYXBwZXIuZ2V0TmF0aXZlTWFwKClcbiAgICAgICAgICAgIC50aGVuKG1hcCA9PiB7XG4gICAgICAgICAgICBjb25zdCBvdmVybGF5ID0gdGhpcy5nZXRPdmVybGF5KG1hcCk7XG4gICAgICAgICAgICB0aGlzLl9tYXJrZXJNYW5hZ2VyLmFkZE1hcmtlcihvdmVybGF5KTtcbiAgICAgICAgICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWFya2VyTWFuYWdlci5nZXROYXRpdmVNYXJrZXIob3ZlcmxheSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihuYXRpdmVNYXJrZXIgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2V0TWFwID0gbmF0aXZlTWFya2VyLnNldE1hcDtcbiAgICAgICAgICAgIGlmIChuYXRpdmVNYXJrZXJbJ21hcCddKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vdmVybGF5Vmlldy5zZXRNYXAobmF0aXZlTWFya2VyWydtYXAnXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuYXRpdmVNYXJrZXIuc2V0TWFwID0gKG1hcCkgPT4ge1xuICAgICAgICAgICAgICAgIHNldE1hcC5jYWxsKG5hdGl2ZU1hcmtlciwgbWFwKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vdmVybGF5Vmlldykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm92ZXJsYXlWaWV3LnNldE1hcChtYXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRPdmVybGF5KG1hcCkge1xuICAgICAgICB0aGlzLm92ZXJsYXlWaWV3ID0gdGhpcy5vdmVybGF5VmlldyB8fCBuZXcgZ29vZ2xlLm1hcHMuT3ZlcmxheVZpZXcoKTtcbiAgICAgICAgLyogbWFrZSBpbnRvIGZvbyBtYXJrZXIgdGhhdCBBR00gbGlrZXMgKi9cbiAgICAgICAgdGhpcy5vdmVybGF5Vmlldy5pY29uVXJsID0gXCIgXCI7XG4gICAgICAgIHRoaXMub3ZlcmxheVZpZXcubGF0aXR1ZGUgPSB0aGlzLmxhdGl0dWRlO1xuICAgICAgICB0aGlzLm92ZXJsYXlWaWV3LmxvbmdpdHVkZSA9IHRoaXMubG9uZ2l0dWRlO1xuICAgICAgICB0aGlzLm92ZXJsYXlWaWV3LnZpc2libGUgPSBmYWxzZTsgLy9oaWRlIDQweDQwIHRyYW5zcGFyZW50IHBsYWNlaG9sZGVyIHRoYXQgcHJldmVudHMgaG92ZXIgZXZlbnRzXG4gICAgICAgIC8qIGVuZCAqL1xuICAgICAgICBpZiAodGhpcy5ib3VuZHMpIHtcbiAgICAgICAgICAgIHRoaXMub3ZlcmxheVZpZXcuYm91bmRzXyA9IG5ldyBnb29nbGUubWFwcy5MYXRMbmdCb3VuZHMobmV3IGdvb2dsZS5tYXBzLkxhdExuZyh0aGlzLmxhdGl0dWRlICsgdGhpcy5ib3VuZHMueC5sYXRpdHVkZSwgdGhpcy5sb25naXR1ZGUgKyB0aGlzLmJvdW5kcy54LmxvbmdpdHVkZSksIG5ldyBnb29nbGUubWFwcy5MYXRMbmcodGhpcy5sYXRpdHVkZSArIHRoaXMuYm91bmRzLnkubGF0aXR1ZGUsIHRoaXMubG9uZ2l0dWRlICsgdGhpcy5ib3VuZHMueS5sb25naXR1ZGUpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBqcy1tYXJrZXItY2x1c3RlcmVyIGRvZXMgbm90IHN1cHBvcnQgdXBkYXRpbmcgcG9zaXRpb25zLiBXZSBhcmUgZm9yY2VkIHRvIGRlbGV0ZS9hZGQgYW5kIGNvbXBlbnNhdGUgZm9yIC5yZW1vdmVDaGlsZCBjYWxsc1xuICAgICAgICBjb25zdCBlbG0gPSB0aGlzLnRlbXBsYXRlLm5hdGl2ZUVsZW1lbnQuY2hpbGRyZW5bMF07XG4gICAgICAgIC8vY29uc3QgZWxtID0gIHRoaXMuZWxtR3V0cyB8fCB0aGlzLnRlbXBsYXRlLm5hdGl2ZUVsZW1lbnQuY2hpbGRyZW5bMF1cbiAgICAgICAgLy93ZSBtdXN0IGFsd2F5cyBiZSBzdXJlIHRvIHN0ZWFsIG91ciBzdG9sZW4gZWxlbWVudCBiYWNrIGluY2FzZSB3ZSBhcmUganVzdCBpbiBtaWRkbGUgb2YgY2hhbmdlcyBhbmQgd2lsbCByZWRyYXdcbiAgICAgICAgY29uc3QgcmVzdG9yZSA9IChkaXYpID0+IHtcbiAgICAgICAgICAgIHRoaXMudGVtcGxhdGUubmF0aXZlRWxlbWVudC5hcHBlbmRDaGlsZChkaXYpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm92ZXJsYXlWaWV3LnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5kaXYpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5kaXYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRpdik7XG4gICAgICAgICAgICByZXN0b3JlKHRoaXMuZGl2KTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmRpdjtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vdmVybGF5Vmlldy5nZXREaXYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kaXY7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub3ZlcmxheVZpZXcuZHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5kaXYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpdiA9IGVsbTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYW5lcyA9IHRoaXMuZ2V0UGFuZXMoKTtcbiAgICAgICAgICAgICAgICAvLyBpZiBubyBwYW5lcyB0aGVuIGFzc3VtZWQgbm90IG9uIG1hcFxuICAgICAgICAgICAgICAgIGlmICghcGFuZXMgfHwgIXBhbmVzLm92ZXJsYXlJbWFnZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHBhbmVzLm92ZXJsYXlJbWFnZS5hcHBlbmRDaGlsZChlbG0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGF0bG5nID0gbmV3IGdvb2dsZS5tYXBzLkxhdExuZyh0aGlzLmxhdGl0dWRlLCB0aGlzLmxvbmdpdHVkZSk7XG4gICAgICAgICAgICBjb25zdCBwcm9qID0gdGhpcy5nZXRQcm9qZWN0aW9uKCk7XG4gICAgICAgICAgICBpZiAoIXByb2opXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgcG9pbnQgPSBwcm9qLmZyb21MYXRMbmdUb0RpdlBpeGVsKGxhdGxuZyk7XG4gICAgICAgICAgICBpZiAocG9pbnQpIHtcbiAgICAgICAgICAgICAgICBlbG0uc3R5bGUubGVmdCA9IChwb2ludC54IC0gMTApICsgJ3B4JztcbiAgICAgICAgICAgICAgICBlbG0uc3R5bGUudG9wID0gKHBvaW50LnkgLSAyMCkgKyAncHgnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuYm91bmRzXykge1xuICAgICAgICAgICAgICAgIC8vIHN0cmV0Y2ggY29udGVudCBiZXR3ZWVuIHR3byBwb2ludHMgbGVmdGJvdHRvbSBhbmQgcmlnaHR0b3AgYW5kIHJlc2l6ZVxuICAgICAgICAgICAgICAgIGNvbnN0IHByb2ogPSB0aGlzLmdldFByb2plY3Rpb24oKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdyA9IHByb2ouZnJvbUxhdExuZ1RvRGl2UGl4ZWwodGhpcy5ib3VuZHNfLmdldFNvdXRoV2VzdCgpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZSA9IHByb2ouZnJvbUxhdExuZ1RvRGl2UGl4ZWwodGhpcy5ib3VuZHNfLmdldE5vcnRoRWFzdCgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpdi5zdHlsZS5sZWZ0ID0gc3cueCArICdweCc7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXYuc3R5bGUudG9wID0gbmUueSArICdweCc7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXYuY2hpbGRyZW5bMF0uc3R5bGUud2lkdGggPSBuZS54IC0gc3cueCArICdweCc7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXYuY2hpbGRyZW5bMF0uc3R5bGUuaGVpZ2h0ID0gc3cueSAtIG5lLnkgKyAncHgnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBlbG0uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlVGFwKCk7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaGFuZGxlSW5mb1dpbmRvd1VwZGF0ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5vdmVybGF5VmlldztcbiAgICB9XG4gICAgaGFuZGxlVGFwKCkge1xuICAgICAgICBpZiAodGhpcy5vcGVuSW5mb1dpbmRvdykge1xuICAgICAgICAgICAgdGhpcy5pbmZvV2luZG93LmZvckVhY2goaW5mb1dpbmRvdyA9PiB7XG4gICAgICAgICAgICAgICAgaW5mb1dpbmRvdy5vcGVuKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1hcmtlckNsaWNrLmVtaXQobnVsbCk7XG4gICAgfVxuICAgIF9hZGRFdmVudExpc3RlbmVycygpIHtcbiAgICAgICAgY29uc3QgZW8gPSB0aGlzLl9tYXJrZXJNYW5hZ2VyLmNyZWF0ZUV2ZW50T2JzZXJ2YWJsZSgnY2xpY2snLCB0aGlzLm92ZXJsYXlWaWV3KTtcbiAgICAgICAgY29uc3QgY3MgPSBlby5zdWJzY3JpYmUoKCkgPT4gdGhpcy5oYW5kbGVUYXAoKSk7XG4gICAgICAgIHRoaXMuX29ic2VydmFibGVTdWJzY3JpcHRpb25zLnB1c2goY3MpO1xuICAgIH1cbn07XG5BZ21PdmVybGF5LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogR29vZ2xlTWFwc0FQSVdyYXBwZXIgfSxcbiAgICB7IHR5cGU6IE1hcmtlck1hbmFnZXIgLy9yZW5hbWUgdG8gZmlnaHQgdGhlIHByaXZhdGUgZGVjbGFyYXRpb24gb2YgcGFyZW50XG4gICAgIH1cbl07XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpXG5dLCBBZ21PdmVybGF5LnByb3RvdHlwZSwgXCJsYXRpdHVkZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKVxuXSwgQWdtT3ZlcmxheS5wcm90b3R5cGUsIFwibG9uZ2l0dWRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpXG5dLCBBZ21PdmVybGF5LnByb3RvdHlwZSwgXCJ2aXNpYmxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpXG5dLCBBZ21PdmVybGF5LnByb3RvdHlwZSwgXCJ6SW5kZXhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KClcbl0sIEFnbU92ZXJsYXkucHJvdG90eXBlLCBcImJvdW5kc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KClcbl0sIEFnbU92ZXJsYXkucHJvdG90eXBlLCBcIm1hcmtlckNsaWNrXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpXG5dLCBBZ21PdmVybGF5LnByb3RvdHlwZSwgXCJvcGVuSW5mb1dpbmRvd1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkcmVuKEFnbUluZm9XaW5kb3cpXG5dLCBBZ21PdmVybGF5LnByb3RvdHlwZSwgXCJpbmZvV2luZG93XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgnbWFya2VyRHJhZ2dhYmxlJylcbl0sIEFnbU92ZXJsYXkucHJvdG90eXBlLCBcImRyYWdnYWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgVmlld0NoaWxkKCdjb250ZW50JywgeyByZWFkOiBFbGVtZW50UmVmIH0pXG5dLCBBZ21PdmVybGF5LnByb3RvdHlwZSwgXCJ0ZW1wbGF0ZVwiLCB2b2lkIDApO1xuQWdtT3ZlcmxheSA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiBcImFnbS1vdmVybGF5XCIsXG4gICAgICAgIHRlbXBsYXRlOiAnPGRpdiAjY29udGVudD48ZGl2IHN0eWxlPVwicG9zaXRpb246YWJzb2x1dGVcIj48bmctY29udGVudD48L25nLWNvbnRlbnQ+PC9kaXY+PC9kaXY+J1xuICAgIH0pXG5dLCBBZ21PdmVybGF5KTtcblxubGV0IEFnbU92ZXJsYXlzID0gY2xhc3MgQWdtT3ZlcmxheXMge1xufTtcbkFnbU92ZXJsYXlzID0gX19kZWNvcmF0ZShbXG4gICAgTmdNb2R1bGUoe1xuICAgICAgICBpbXBvcnRzOiBbXG4gICAgICAgICAgICBDb21tb25Nb2R1bGVcbiAgICAgICAgXSxcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbQWdtT3ZlcmxheV0sXG4gICAgICAgIGV4cG9ydHM6IFtBZ21PdmVybGF5XSxcbiAgICB9KVxuXSwgQWdtT3ZlcmxheXMpO1xuXG4vKipcbiAqIEdlbmVyYXRlZCBidW5kbGUgaW5kZXguIERvIG5vdCBlZGl0LlxuICovXG5cbmV4cG9ydCB7IEFnbU92ZXJsYXksIEFnbU92ZXJsYXlzIH07XG4iXX0=